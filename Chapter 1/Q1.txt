1.1-1:
Logistics, airline companies, ISP's.
1.1-2:
Memory is an important factor. Moreover if an algorithm is parallelizable, it might be more efficient than a faster non-parallelizable one.
1.1-3:
I have seen vectors. These are good for efficiently accessing different values. However it is difficult to append elements to vectors. Moreover, this data type requires a contiguous chunk of memory, making it less versatile as linked lists for example.
1.1-4:
They both look to optimize travel on a graph. However the shortest path problem only cares about going from one point to another, while the traveling-salesman must visit every node.
1.1-5:
Synchronizing traffic lights requires precision.
Calculating an itinerary often only requires a "good enough" solution.

1.2-1:
Calculating an optimal route. The algorithms allow us to find the one that takes the least time.
1.2-2:
We want n/log(n) < 8. This holds for 0 <= n <= 6.
1.2-3:
The smallest value of n is 15.

1-1:
Plug in the times into inverses of the functions [...].
